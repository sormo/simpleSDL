// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_MODELDATA_H_
#define FLATBUFFERS_GENERATED_MODEL_MODELDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace ModelData {

struct Vec3;

struct Vec2;

struct Color;

struct Mat4;

struct Texture;
struct TextureT;

struct Material;
struct MaterialT;

struct Mesh;
struct MeshT;

struct Tree;
struct TreeT;

struct Model;
struct ModelT;

enum TextureOperation {
  TextureOperation_Multiply = 0,
  TextureOperation_Add = 1,
  TextureOperation_Substract = 2,
  TextureOperation_Divide = 3,
  TextureOperation_SmoothAdd = 4,
  TextureOperation_SignedAdd = 5,
  TextureOperation_MIN = TextureOperation_Multiply,
  TextureOperation_MAX = TextureOperation_SignedAdd
};

inline const TextureOperation (&EnumValuesTextureOperation())[6] {
  static const TextureOperation values[] = {
    TextureOperation_Multiply,
    TextureOperation_Add,
    TextureOperation_Substract,
    TextureOperation_Divide,
    TextureOperation_SmoothAdd,
    TextureOperation_SignedAdd
  };
  return values;
}

inline const char * const *EnumNamesTextureOperation() {
  static const char * const names[] = {
    "Multiply",
    "Add",
    "Substract",
    "Divide",
    "SmoothAdd",
    "SignedAdd",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureOperation(TextureOperation e) {
  if (e < TextureOperation_Multiply || e > TextureOperation_SignedAdd) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesTextureOperation()[index];
}

enum TextureMapMode {
  TextureMapMode_Wrap = 0,
  TextureMapMode_Clamp = 1,
  TextureMapMode_Decal = 2,
  TextureMapMode_Mirror = 3,
  TextureMapMode_MIN = TextureMapMode_Wrap,
  TextureMapMode_MAX = TextureMapMode_Mirror
};

inline const TextureMapMode (&EnumValuesTextureMapMode())[4] {
  static const TextureMapMode values[] = {
    TextureMapMode_Wrap,
    TextureMapMode_Clamp,
    TextureMapMode_Decal,
    TextureMapMode_Mirror
  };
  return values;
}

inline const char * const *EnumNamesTextureMapMode() {
  static const char * const names[] = {
    "Wrap",
    "Clamp",
    "Decal",
    "Mirror",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureMapMode(TextureMapMode e) {
  if (e < TextureMapMode_Wrap || e > TextureMapMode_Mirror) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesTextureMapMode()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  Color() {
    memset(this, 0, sizeof(Color));
  }
  Color(float _r, float _g, float _b, float _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4 FLATBUFFERS_FINAL_CLASS {
 private:
  float a1_;
  float a2_;
  float a3_;
  float a4_;
  float b1_;
  float b2_;
  float b3_;
  float b4_;
  float c1_;
  float c2_;
  float c3_;
  float c4_;
  float d1_;
  float d2_;
  float d3_;
  float d4_;

 public:
  Mat4() {
    memset(this, 0, sizeof(Mat4));
  }
  Mat4(float _a1, float _a2, float _a3, float _a4, float _b1, float _b2, float _b3, float _b4, float _c1, float _c2, float _c3, float _c4, float _d1, float _d2, float _d3, float _d4)
      : a1_(flatbuffers::EndianScalar(_a1)),
        a2_(flatbuffers::EndianScalar(_a2)),
        a3_(flatbuffers::EndianScalar(_a3)),
        a4_(flatbuffers::EndianScalar(_a4)),
        b1_(flatbuffers::EndianScalar(_b1)),
        b2_(flatbuffers::EndianScalar(_b2)),
        b3_(flatbuffers::EndianScalar(_b3)),
        b4_(flatbuffers::EndianScalar(_b4)),
        c1_(flatbuffers::EndianScalar(_c1)),
        c2_(flatbuffers::EndianScalar(_c2)),
        c3_(flatbuffers::EndianScalar(_c3)),
        c4_(flatbuffers::EndianScalar(_c4)),
        d1_(flatbuffers::EndianScalar(_d1)),
        d2_(flatbuffers::EndianScalar(_d2)),
        d3_(flatbuffers::EndianScalar(_d3)),
        d4_(flatbuffers::EndianScalar(_d4)) {
  }
  float a1() const {
    return flatbuffers::EndianScalar(a1_);
  }
  float a2() const {
    return flatbuffers::EndianScalar(a2_);
  }
  float a3() const {
    return flatbuffers::EndianScalar(a3_);
  }
  float a4() const {
    return flatbuffers::EndianScalar(a4_);
  }
  float b1() const {
    return flatbuffers::EndianScalar(b1_);
  }
  float b2() const {
    return flatbuffers::EndianScalar(b2_);
  }
  float b3() const {
    return flatbuffers::EndianScalar(b3_);
  }
  float b4() const {
    return flatbuffers::EndianScalar(b4_);
  }
  float c1() const {
    return flatbuffers::EndianScalar(c1_);
  }
  float c2() const {
    return flatbuffers::EndianScalar(c2_);
  }
  float c3() const {
    return flatbuffers::EndianScalar(c3_);
  }
  float c4() const {
    return flatbuffers::EndianScalar(c4_);
  }
  float d1() const {
    return flatbuffers::EndianScalar(d1_);
  }
  float d2() const {
    return flatbuffers::EndianScalar(d2_);
  }
  float d3() const {
    return flatbuffers::EndianScalar(d3_);
  }
  float d4() const {
    return flatbuffers::EndianScalar(d4_);
  }
};
FLATBUFFERS_STRUCT_END(Mat4, 64);

struct TextureT : public flatbuffers::NativeTable {
  typedef Texture TableType;
  std::string path;
  uint32_t uvIndex;
  float blendFactor;
  TextureOperation operation;
  TextureMapMode mappingU;
  TextureMapMode mappingV;
  TextureT()
      : uvIndex(0),
        blendFactor(1.0f),
        operation(TextureOperation_Multiply),
        mappingU(TextureMapMode_Wrap),
        mappingV(TextureMapMode_Wrap) {
  }
};

struct Texture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_UVINDEX = 6,
    VT_BLENDFACTOR = 8,
    VT_OPERATION = 10,
    VT_MAPPINGU = 12,
    VT_MAPPINGV = 14
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  uint32_t uvIndex() const {
    return GetField<uint32_t>(VT_UVINDEX, 0);
  }
  float blendFactor() const {
    return GetField<float>(VT_BLENDFACTOR, 1.0f);
  }
  TextureOperation operation() const {
    return static_cast<TextureOperation>(GetField<int8_t>(VT_OPERATION, 0));
  }
  TextureMapMode mappingU() const {
    return static_cast<TextureMapMode>(GetField<int8_t>(VT_MAPPINGU, 0));
  }
  TextureMapMode mappingV() const {
    return static_cast<TextureMapMode>(GetField<int8_t>(VT_MAPPINGV, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<uint32_t>(verifier, VT_UVINDEX) &&
           VerifyField<float>(verifier, VT_BLENDFACTOR) &&
           VerifyField<int8_t>(verifier, VT_OPERATION) &&
           VerifyField<int8_t>(verifier, VT_MAPPINGU) &&
           VerifyField<int8_t>(verifier, VT_MAPPINGV) &&
           verifier.EndTable();
  }
  TextureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Texture> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Texture::VT_PATH, path);
  }
  void add_uvIndex(uint32_t uvIndex) {
    fbb_.AddElement<uint32_t>(Texture::VT_UVINDEX, uvIndex, 0);
  }
  void add_blendFactor(float blendFactor) {
    fbb_.AddElement<float>(Texture::VT_BLENDFACTOR, blendFactor, 1.0f);
  }
  void add_operation(TextureOperation operation) {
    fbb_.AddElement<int8_t>(Texture::VT_OPERATION, static_cast<int8_t>(operation), 0);
  }
  void add_mappingU(TextureMapMode mappingU) {
    fbb_.AddElement<int8_t>(Texture::VT_MAPPINGU, static_cast<int8_t>(mappingU), 0);
  }
  void add_mappingV(TextureMapMode mappingV) {
    fbb_.AddElement<int8_t>(Texture::VT_MAPPINGV, static_cast<int8_t>(mappingV), 0);
  }
  explicit TextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureBuilder &operator=(const TextureBuilder &);
  flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Texture> CreateTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    uint32_t uvIndex = 0,
    float blendFactor = 1.0f,
    TextureOperation operation = TextureOperation_Multiply,
    TextureMapMode mappingU = TextureMapMode_Wrap,
    TextureMapMode mappingV = TextureMapMode_Wrap) {
  TextureBuilder builder_(_fbb);
  builder_.add_blendFactor(blendFactor);
  builder_.add_uvIndex(uvIndex);
  builder_.add_path(path);
  builder_.add_mappingV(mappingV);
  builder_.add_mappingU(mappingU);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline flatbuffers::Offset<Texture> CreateTextureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    uint32_t uvIndex = 0,
    float blendFactor = 1.0f,
    TextureOperation operation = TextureOperation_Multiply,
    TextureMapMode mappingU = TextureMapMode_Wrap,
    TextureMapMode mappingV = TextureMapMode_Wrap) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return ModelData::CreateTexture(
      _fbb,
      path__,
      uvIndex,
      blendFactor,
      operation,
      mappingU,
      mappingV);
}

flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder &_fbb, const TextureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaterialT : public flatbuffers::NativeTable {
  typedef Material TableType;
  std::unique_ptr<Color> ambient;
  std::unique_ptr<Color> diffuse;
  std::unique_ptr<Color> specular;
  float shininess;
  float shininessStrength;
  std::vector<std::unique_ptr<TextureT>> textureAmbient;
  std::vector<std::unique_ptr<TextureT>> textureDiffuse;
  std::vector<std::unique_ptr<TextureT>> textureSpecular;
  std::vector<std::unique_ptr<TextureT>> textureNormal;
  std::vector<std::unique_ptr<TextureT>> textureShininess;
  std::vector<std::unique_ptr<TextureT>> textureHeight;
  std::vector<std::unique_ptr<TextureT>> textureEmissive;
  std::vector<std::unique_ptr<TextureT>> textureOpacity;
  std::vector<std::unique_ptr<TextureT>> textureLightmap;
  MaterialT()
      : shininess(0.0f),
        shininessStrength(1.0f) {
  }
};

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMBIENT = 4,
    VT_DIFFUSE = 6,
    VT_SPECULAR = 8,
    VT_SHININESS = 10,
    VT_SHININESSSTRENGTH = 12,
    VT_TEXTUREAMBIENT = 14,
    VT_TEXTUREDIFFUSE = 16,
    VT_TEXTURESPECULAR = 18,
    VT_TEXTURENORMAL = 20,
    VT_TEXTURESHININESS = 22,
    VT_TEXTUREHEIGHT = 24,
    VT_TEXTUREEMISSIVE = 26,
    VT_TEXTUREOPACITY = 28,
    VT_TEXTURELIGHTMAP = 30
  };
  const Color *ambient() const {
    return GetStruct<const Color *>(VT_AMBIENT);
  }
  const Color *diffuse() const {
    return GetStruct<const Color *>(VT_DIFFUSE);
  }
  const Color *specular() const {
    return GetStruct<const Color *>(VT_SPECULAR);
  }
  float shininess() const {
    return GetField<float>(VT_SHININESS, 0.0f);
  }
  float shininessStrength() const {
    return GetField<float>(VT_SHININESSSTRENGTH, 1.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureAmbient() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTUREAMBIENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureDiffuse() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTUREDIFFUSE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureSpecular() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTURESPECULAR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureNormal() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTURENORMAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureShininess() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTURESHININESS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureHeight() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTUREHEIGHT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureEmissive() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTUREEMISSIVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureOpacity() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTUREOPACITY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textureLightmap() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTURELIGHTMAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Color>(verifier, VT_AMBIENT) &&
           VerifyField<Color>(verifier, VT_DIFFUSE) &&
           VerifyField<Color>(verifier, VT_SPECULAR) &&
           VerifyField<float>(verifier, VT_SHININESS) &&
           VerifyField<float>(verifier, VT_SHININESSSTRENGTH) &&
           VerifyOffset(verifier, VT_TEXTUREAMBIENT) &&
           verifier.VerifyVector(textureAmbient()) &&
           verifier.VerifyVectorOfTables(textureAmbient()) &&
           VerifyOffset(verifier, VT_TEXTUREDIFFUSE) &&
           verifier.VerifyVector(textureDiffuse()) &&
           verifier.VerifyVectorOfTables(textureDiffuse()) &&
           VerifyOffset(verifier, VT_TEXTURESPECULAR) &&
           verifier.VerifyVector(textureSpecular()) &&
           verifier.VerifyVectorOfTables(textureSpecular()) &&
           VerifyOffset(verifier, VT_TEXTURENORMAL) &&
           verifier.VerifyVector(textureNormal()) &&
           verifier.VerifyVectorOfTables(textureNormal()) &&
           VerifyOffset(verifier, VT_TEXTURESHININESS) &&
           verifier.VerifyVector(textureShininess()) &&
           verifier.VerifyVectorOfTables(textureShininess()) &&
           VerifyOffset(verifier, VT_TEXTUREHEIGHT) &&
           verifier.VerifyVector(textureHeight()) &&
           verifier.VerifyVectorOfTables(textureHeight()) &&
           VerifyOffset(verifier, VT_TEXTUREEMISSIVE) &&
           verifier.VerifyVector(textureEmissive()) &&
           verifier.VerifyVectorOfTables(textureEmissive()) &&
           VerifyOffset(verifier, VT_TEXTUREOPACITY) &&
           verifier.VerifyVector(textureOpacity()) &&
           verifier.VerifyVectorOfTables(textureOpacity()) &&
           VerifyOffset(verifier, VT_TEXTURELIGHTMAP) &&
           verifier.VerifyVector(textureLightmap()) &&
           verifier.VerifyVectorOfTables(textureLightmap()) &&
           verifier.EndTable();
  }
  MaterialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaterialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Material> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaterialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ambient(const Color *ambient) {
    fbb_.AddStruct(Material::VT_AMBIENT, ambient);
  }
  void add_diffuse(const Color *diffuse) {
    fbb_.AddStruct(Material::VT_DIFFUSE, diffuse);
  }
  void add_specular(const Color *specular) {
    fbb_.AddStruct(Material::VT_SPECULAR, specular);
  }
  void add_shininess(float shininess) {
    fbb_.AddElement<float>(Material::VT_SHININESS, shininess, 0.0f);
  }
  void add_shininessStrength(float shininessStrength) {
    fbb_.AddElement<float>(Material::VT_SHININESSSTRENGTH, shininessStrength, 1.0f);
  }
  void add_textureAmbient(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureAmbient) {
    fbb_.AddOffset(Material::VT_TEXTUREAMBIENT, textureAmbient);
  }
  void add_textureDiffuse(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureDiffuse) {
    fbb_.AddOffset(Material::VT_TEXTUREDIFFUSE, textureDiffuse);
  }
  void add_textureSpecular(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureSpecular) {
    fbb_.AddOffset(Material::VT_TEXTURESPECULAR, textureSpecular);
  }
  void add_textureNormal(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureNormal) {
    fbb_.AddOffset(Material::VT_TEXTURENORMAL, textureNormal);
  }
  void add_textureShininess(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureShininess) {
    fbb_.AddOffset(Material::VT_TEXTURESHININESS, textureShininess);
  }
  void add_textureHeight(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureHeight) {
    fbb_.AddOffset(Material::VT_TEXTUREHEIGHT, textureHeight);
  }
  void add_textureEmissive(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureEmissive) {
    fbb_.AddOffset(Material::VT_TEXTUREEMISSIVE, textureEmissive);
  }
  void add_textureOpacity(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureOpacity) {
    fbb_.AddOffset(Material::VT_TEXTUREOPACITY, textureOpacity);
  }
  void add_textureLightmap(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureLightmap) {
    fbb_.AddOffset(Material::VT_TEXTURELIGHTMAP, textureLightmap);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Color *ambient = 0,
    const Color *diffuse = 0,
    const Color *specular = 0,
    float shininess = 0.0f,
    float shininessStrength = 1.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureAmbient = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureDiffuse = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureSpecular = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureNormal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureShininess = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureHeight = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureEmissive = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureOpacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textureLightmap = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_textureLightmap(textureLightmap);
  builder_.add_textureOpacity(textureOpacity);
  builder_.add_textureEmissive(textureEmissive);
  builder_.add_textureHeight(textureHeight);
  builder_.add_textureShininess(textureShininess);
  builder_.add_textureNormal(textureNormal);
  builder_.add_textureSpecular(textureSpecular);
  builder_.add_textureDiffuse(textureDiffuse);
  builder_.add_textureAmbient(textureAmbient);
  builder_.add_shininessStrength(shininessStrength);
  builder_.add_shininess(shininess);
  builder_.add_specular(specular);
  builder_.add_diffuse(diffuse);
  builder_.add_ambient(ambient);
  return builder_.Finish();
}

inline flatbuffers::Offset<Material> CreateMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Color *ambient = 0,
    const Color *diffuse = 0,
    const Color *specular = 0,
    float shininess = 0.0f,
    float shininessStrength = 1.0f,
    const std::vector<flatbuffers::Offset<Texture>> *textureAmbient = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureDiffuse = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureSpecular = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureNormal = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureShininess = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureHeight = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureEmissive = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureOpacity = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textureLightmap = nullptr) {
  auto textureAmbient__ = textureAmbient ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureAmbient) : 0;
  auto textureDiffuse__ = textureDiffuse ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureDiffuse) : 0;
  auto textureSpecular__ = textureSpecular ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureSpecular) : 0;
  auto textureNormal__ = textureNormal ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureNormal) : 0;
  auto textureShininess__ = textureShininess ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureShininess) : 0;
  auto textureHeight__ = textureHeight ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureHeight) : 0;
  auto textureEmissive__ = textureEmissive ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureEmissive) : 0;
  auto textureOpacity__ = textureOpacity ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureOpacity) : 0;
  auto textureLightmap__ = textureLightmap ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textureLightmap) : 0;
  return ModelData::CreateMaterial(
      _fbb,
      ambient,
      diffuse,
      specular,
      shininess,
      shininessStrength,
      textureAmbient__,
      textureDiffuse__,
      textureSpecular__,
      textureNormal__,
      textureShininess__,
      textureHeight__,
      textureEmissive__,
      textureOpacity__,
      textureLightmap__);
}

flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder &_fbb, const MaterialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshT : public flatbuffers::NativeTable {
  typedef Mesh TableType;
  std::vector<Vec3> positions;
  std::vector<Vec3> normals;
  std::vector<Vec2> texCoords;
  std::vector<Vec3> tangents;
  std::vector<Vec3> bitangents;
  std::vector<uint16_t> indices;
  uint32_t material;
  std::vector<Color> colors;
  std::unique_ptr<Mat4> transform;
  MeshT()
      : material(0) {
  }
};

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONS = 4,
    VT_NORMALS = 6,
    VT_TEXCOORDS = 8,
    VT_TANGENTS = 10,
    VT_BITANGENTS = 12,
    VT_INDICES = 14,
    VT_MATERIAL = 16,
    VT_COLORS = 18,
    VT_TRANSFORM = 20
  };
  const flatbuffers::Vector<const Vec3 *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_POSITIONS);
  }
  const flatbuffers::Vector<const Vec3 *> *normals() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_NORMALS);
  }
  const flatbuffers::Vector<const Vec2 *> *texCoords() const {
    return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_TEXCOORDS);
  }
  const flatbuffers::Vector<const Vec3 *> *tangents() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_TANGENTS);
  }
  const flatbuffers::Vector<const Vec3 *> *bitangents() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_BITANGENTS);
  }
  const flatbuffers::Vector<uint16_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_INDICES);
  }
  uint32_t material() const {
    return GetField<uint32_t>(VT_MATERIAL, 0);
  }
  const flatbuffers::Vector<const Color *> *colors() const {
    return GetPointer<const flatbuffers::Vector<const Color *> *>(VT_COLORS);
  }
  const Mat4 *transform() const {
    return GetStruct<const Mat4 *>(VT_TRANSFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyVector(normals()) &&
           VerifyOffset(verifier, VT_TEXCOORDS) &&
           verifier.VerifyVector(texCoords()) &&
           VerifyOffset(verifier, VT_TANGENTS) &&
           verifier.VerifyVector(tangents()) &&
           VerifyOffset(verifier, VT_BITANGENTS) &&
           verifier.VerifyVector(bitangents()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyField<uint32_t>(verifier, VT_MATERIAL) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           VerifyField<Mat4>(verifier, VT_TRANSFORM) &&
           verifier.EndTable();
  }
  MeshT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mesh> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> positions) {
    fbb_.AddOffset(Mesh::VT_POSITIONS, positions);
  }
  void add_normals(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> normals) {
    fbb_.AddOffset(Mesh::VT_NORMALS, normals);
  }
  void add_texCoords(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> texCoords) {
    fbb_.AddOffset(Mesh::VT_TEXCOORDS, texCoords);
  }
  void add_tangents(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> tangents) {
    fbb_.AddOffset(Mesh::VT_TANGENTS, tangents);
  }
  void add_bitangents(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> bitangents) {
    fbb_.AddOffset(Mesh::VT_BITANGENTS, bitangents);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> indices) {
    fbb_.AddOffset(Mesh::VT_INDICES, indices);
  }
  void add_material(uint32_t material) {
    fbb_.AddElement<uint32_t>(Mesh::VT_MATERIAL, material, 0);
  }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<const Color *>> colors) {
    fbb_.AddOffset(Mesh::VT_COLORS, colors);
  }
  void add_transform(const Mat4 *transform) {
    fbb_.AddStruct(Mesh::VT_TRANSFORM, transform);
  }
  explicit MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> normals = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> texCoords = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> tangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> bitangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> indices = 0,
    uint32_t material = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Color *>> colors = 0,
    const Mat4 *transform = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_colors(colors);
  builder_.add_material(material);
  builder_.add_indices(indices);
  builder_.add_bitangents(bitangents);
  builder_.add_tangents(tangents);
  builder_.add_texCoords(texCoords);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mesh> CreateMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Vec3> *positions = nullptr,
    const std::vector<Vec3> *normals = nullptr,
    const std::vector<Vec2> *texCoords = nullptr,
    const std::vector<Vec3> *tangents = nullptr,
    const std::vector<Vec3> *bitangents = nullptr,
    const std::vector<uint16_t> *indices = nullptr,
    uint32_t material = 0,
    const std::vector<Color> *colors = nullptr,
    const Mat4 *transform = 0) {
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<Vec3>(*positions) : 0;
  auto normals__ = normals ? _fbb.CreateVectorOfStructs<Vec3>(*normals) : 0;
  auto texCoords__ = texCoords ? _fbb.CreateVectorOfStructs<Vec2>(*texCoords) : 0;
  auto tangents__ = tangents ? _fbb.CreateVectorOfStructs<Vec3>(*tangents) : 0;
  auto bitangents__ = bitangents ? _fbb.CreateVectorOfStructs<Vec3>(*bitangents) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint16_t>(*indices) : 0;
  auto colors__ = colors ? _fbb.CreateVectorOfStructs<Color>(*colors) : 0;
  return ModelData::CreateMesh(
      _fbb,
      positions__,
      normals__,
      texCoords__,
      tangents__,
      bitangents__,
      indices__,
      material,
      colors__,
      transform);
}

flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb, const MeshT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TreeT : public flatbuffers::NativeTable {
  typedef Tree TableType;
  std::unique_ptr<Mat4> transform;
  std::vector<std::unique_ptr<TreeT>> childs;
  std::vector<uint32_t> meshes;
  TreeT() {
  }
};

struct Tree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TreeT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSFORM = 4,
    VT_CHILDS = 6,
    VT_MESHES = 8
  };
  const Mat4 *transform() const {
    return GetStruct<const Mat4 *>(VT_TRANSFORM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tree>> *childs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tree>> *>(VT_CHILDS);
  }
  const flatbuffers::Vector<uint32_t> *meshes() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MESHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Mat4>(verifier, VT_TRANSFORM) &&
           VerifyOffset(verifier, VT_CHILDS) &&
           verifier.VerifyVector(childs()) &&
           verifier.VerifyVectorOfTables(childs()) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.EndTable();
  }
  TreeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TreeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tree> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TreeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transform(const Mat4 *transform) {
    fbb_.AddStruct(Tree::VT_TRANSFORM, transform);
  }
  void add_childs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tree>>> childs) {
    fbb_.AddOffset(Tree::VT_CHILDS, childs);
  }
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> meshes) {
    fbb_.AddOffset(Tree::VT_MESHES, meshes);
  }
  explicit TreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TreeBuilder &operator=(const TreeBuilder &);
  flatbuffers::Offset<Tree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tree>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tree> CreateTree(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Mat4 *transform = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tree>>> childs = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> meshes = 0) {
  TreeBuilder builder_(_fbb);
  builder_.add_meshes(meshes);
  builder_.add_childs(childs);
  builder_.add_transform(transform);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tree> CreateTreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Mat4 *transform = 0,
    const std::vector<flatbuffers::Offset<Tree>> *childs = nullptr,
    const std::vector<uint32_t> *meshes = nullptr) {
  auto childs__ = childs ? _fbb.CreateVector<flatbuffers::Offset<Tree>>(*childs) : 0;
  auto meshes__ = meshes ? _fbb.CreateVector<uint32_t>(*meshes) : 0;
  return ModelData::CreateTree(
      _fbb,
      transform,
      childs__,
      meshes__);
}

flatbuffers::Offset<Tree> CreateTree(flatbuffers::FlatBufferBuilder &_fbb, const TreeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
  typedef Model TableType;
  std::vector<std::unique_ptr<MeshT>> meshes;
  std::vector<std::unique_ptr<MaterialT>> materials;
  std::unique_ptr<TreeT> tree;
  ModelT() {
  }
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHES = 4,
    VT_MATERIALS = 6,
    VT_TREE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *>(VT_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Material>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Material>> *>(VT_MATERIALS);
  }
  const Tree *tree() const {
    return GetPointer<const Tree *>(VT_TREE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyOffset(verifier, VT_TREE) &&
           verifier.VerifyTable(tree()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes) {
    fbb_.AddOffset(Model::VT_MESHES, meshes);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials) {
    fbb_.AddOffset(Model::VT_MATERIALS, materials);
  }
  void add_tree(flatbuffers::Offset<Tree> tree) {
    fbb_.AddOffset(Model::VT_TREE, tree);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials = 0,
    flatbuffers::Offset<Tree> tree = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_tree(tree);
  builder_.add_materials(materials);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Mesh>> *meshes = nullptr,
    const std::vector<flatbuffers::Offset<Material>> *materials = nullptr,
    flatbuffers::Offset<Tree> tree = 0) {
  auto meshes__ = meshes ? _fbb.CreateVector<flatbuffers::Offset<Mesh>>(*meshes) : 0;
  auto materials__ = materials ? _fbb.CreateVector<flatbuffers::Offset<Material>>(*materials) : 0;
  return ModelData::CreateModel(
      _fbb,
      meshes__,
      materials__,
      tree);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TextureT *Texture::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TextureT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Texture::UnPackTo(TextureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = path(); if (_e) _o->path = _e->str(); };
  { auto _e = uvIndex(); _o->uvIndex = _e; };
  { auto _e = blendFactor(); _o->blendFactor = _e; };
  { auto _e = operation(); _o->operation = _e; };
  { auto _e = mappingU(); _o->mappingU = _e; };
  { auto _e = mappingV(); _o->mappingV = _e; };
}

inline flatbuffers::Offset<Texture> Texture::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTexture(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder &_fbb, const TextureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _path = _o->path.empty() ? 0 : _fbb.CreateString(_o->path);
  auto _uvIndex = _o->uvIndex;
  auto _blendFactor = _o->blendFactor;
  auto _operation = _o->operation;
  auto _mappingU = _o->mappingU;
  auto _mappingV = _o->mappingV;
  return ModelData::CreateTexture(
      _fbb,
      _path,
      _uvIndex,
      _blendFactor,
      _operation,
      _mappingU,
      _mappingV);
}

inline MaterialT *Material::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MaterialT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Material::UnPackTo(MaterialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ambient(); if (_e) _o->ambient = std::unique_ptr<Color>(new Color(*_e)); };
  { auto _e = diffuse(); if (_e) _o->diffuse = std::unique_ptr<Color>(new Color(*_e)); };
  { auto _e = specular(); if (_e) _o->specular = std::unique_ptr<Color>(new Color(*_e)); };
  { auto _e = shininess(); _o->shininess = _e; };
  { auto _e = shininessStrength(); _o->shininessStrength = _e; };
  { auto _e = textureAmbient(); if (_e) { _o->textureAmbient.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureAmbient[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureDiffuse(); if (_e) { _o->textureDiffuse.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureDiffuse[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureSpecular(); if (_e) { _o->textureSpecular.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureSpecular[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureNormal(); if (_e) { _o->textureNormal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureNormal[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureShininess(); if (_e) { _o->textureShininess.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureShininess[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureHeight(); if (_e) { _o->textureHeight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureHeight[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureEmissive(); if (_e) { _o->textureEmissive.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureEmissive[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureOpacity(); if (_e) { _o->textureOpacity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureOpacity[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = textureLightmap(); if (_e) { _o->textureLightmap.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textureLightmap[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Material> Material::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaterialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaterial(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder &_fbb, const MaterialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaterialT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ambient = _o->ambient ? _o->ambient.get() : 0;
  auto _diffuse = _o->diffuse ? _o->diffuse.get() : 0;
  auto _specular = _o->specular ? _o->specular.get() : 0;
  auto _shininess = _o->shininess;
  auto _shininessStrength = _o->shininessStrength;
  auto _textureAmbient = _o->textureAmbient.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureAmbient.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureAmbient[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureDiffuse = _o->textureDiffuse.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureDiffuse.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureDiffuse[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureSpecular = _o->textureSpecular.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureSpecular.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureSpecular[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureNormal = _o->textureNormal.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureNormal.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureNormal[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureShininess = _o->textureShininess.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureShininess.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureShininess[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureHeight = _o->textureHeight.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureHeight.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureHeight[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureEmissive = _o->textureEmissive.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureEmissive.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureEmissive[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureOpacity = _o->textureOpacity.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureOpacity.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureOpacity[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textureLightmap = _o->textureLightmap.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textureLightmap.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textureLightmap[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ModelData::CreateMaterial(
      _fbb,
      _ambient,
      _diffuse,
      _specular,
      _shininess,
      _shininessStrength,
      _textureAmbient,
      _textureDiffuse,
      _textureSpecular,
      _textureNormal,
      _textureShininess,
      _textureHeight,
      _textureEmissive,
      _textureOpacity,
      _textureLightmap);
}

inline MeshT *Mesh::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MeshT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Mesh::UnPackTo(MeshT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = positions(); if (_e) { _o->positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->positions[_i] = *_e->Get(_i); } } };
  { auto _e = normals(); if (_e) { _o->normals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normals[_i] = *_e->Get(_i); } } };
  { auto _e = texCoords(); if (_e) { _o->texCoords.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->texCoords[_i] = *_e->Get(_i); } } };
  { auto _e = tangents(); if (_e) { _o->tangents.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tangents[_i] = *_e->Get(_i); } } };
  { auto _e = bitangents(); if (_e) { _o->bitangents.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bitangents[_i] = *_e->Get(_i); } } };
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indices[_i] = _e->Get(_i); } } };
  { auto _e = material(); _o->material = _e; };
  { auto _e = colors(); if (_e) { _o->colors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->colors[_i] = *_e->Get(_i); } } };
  { auto _e = transform(); if (_e) _o->transform = std::unique_ptr<Mat4>(new Mat4(*_e)); };
}

inline flatbuffers::Offset<Mesh> Mesh::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMesh(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb, const MeshT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _positions = _o->positions.size() ? _fbb.CreateVectorOfStructs(_o->positions) : 0;
  auto _normals = _o->normals.size() ? _fbb.CreateVectorOfStructs(_o->normals) : 0;
  auto _texCoords = _o->texCoords.size() ? _fbb.CreateVectorOfStructs(_o->texCoords) : 0;
  auto _tangents = _o->tangents.size() ? _fbb.CreateVectorOfStructs(_o->tangents) : 0;
  auto _bitangents = _o->bitangents.size() ? _fbb.CreateVectorOfStructs(_o->bitangents) : 0;
  auto _indices = _o->indices.size() ? _fbb.CreateVector(_o->indices) : 0;
  auto _material = _o->material;
  auto _colors = _o->colors.size() ? _fbb.CreateVectorOfStructs(_o->colors) : 0;
  auto _transform = _o->transform ? _o->transform.get() : 0;
  return ModelData::CreateMesh(
      _fbb,
      _positions,
      _normals,
      _texCoords,
      _tangents,
      _bitangents,
      _indices,
      _material,
      _colors,
      _transform);
}

inline TreeT *Tree::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TreeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Tree::UnPackTo(TreeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transform(); if (_e) _o->transform = std::unique_ptr<Mat4>(new Mat4(*_e)); };
  { auto _e = childs(); if (_e) { _o->childs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->childs[_i] = std::unique_ptr<TreeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = meshes(); if (_e) { _o->meshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshes[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Tree> Tree::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TreeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTree(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tree> CreateTree(flatbuffers::FlatBufferBuilder &_fbb, const TreeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TreeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transform = _o->transform ? _o->transform.get() : 0;
  auto _childs = _o->childs.size() ? _fbb.CreateVector<flatbuffers::Offset<Tree>> (_o->childs.size(), [](size_t i, _VectorArgs *__va) { return CreateTree(*__va->__fbb, __va->__o->childs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshes = _o->meshes.size() ? _fbb.CreateVector(_o->meshes) : 0;
  return ModelData::CreateTree(
      _fbb,
      _transform,
      _childs,
      _meshes);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ModelT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = meshes(); if (_e) { _o->meshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshes[_i] = std::unique_ptr<MeshT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = materials(); if (_e) { _o->materials.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->materials[_i] = std::unique_ptr<MaterialT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = tree(); if (_e) _o->tree = std::unique_ptr<TreeT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _meshes = _o->meshes.size() ? _fbb.CreateVector<flatbuffers::Offset<Mesh>> (_o->meshes.size(), [](size_t i, _VectorArgs *__va) { return CreateMesh(*__va->__fbb, __va->__o->meshes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _materials = _o->materials.size() ? _fbb.CreateVector<flatbuffers::Offset<Material>> (_o->materials.size(), [](size_t i, _VectorArgs *__va) { return CreateMaterial(*__va->__fbb, __va->__o->materials[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _tree = _o->tree ? CreateTree(_fbb, _o->tree.get(), _rehasher) : 0;
  return ModelData::CreateModel(
      _fbb,
      _meshes,
      _materials,
      _tree);
}

inline const ModelData::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<ModelData::Model>(buf);
}

inline const ModelData::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ModelData::Model>(buf);
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ModelData::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ModelData::Model>(nullptr);
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ModelData::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ModelData::Model> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ModelT> UnPackModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ModelT>(GetModel(buf)->UnPack(res));
}

}  // namespace ModelData

#endif  // FLATBUFFERS_GENERATED_MODEL_MODELDATA_H_
