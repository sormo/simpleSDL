// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_MODELDATA_H_
#define FLATBUFFERS_GENERATED_MODEL_MODELDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace ModelData {

struct Vec3;

struct Vec2;

struct Texture;
struct TextureT;

struct Mesh;
struct MeshT;

struct Model;
struct ModelT;

enum TextureType {
  TextureType_Diffuse = 0,
  TextureType_Specular = 1,
  TextureType_Normal = 2,
  TextureType_Height = 3,
  TextureType_Ambient = 4,
  TextureType_MIN = TextureType_Diffuse,
  TextureType_MAX = TextureType_Ambient
};

inline const TextureType (&EnumValuesTextureType())[5] {
  static const TextureType values[] = {
    TextureType_Diffuse,
    TextureType_Specular,
    TextureType_Normal,
    TextureType_Height,
    TextureType_Ambient
  };
  return values;
}

inline const char * const *EnumNamesTextureType() {
  static const char * const names[] = {
    "Diffuse",
    "Specular",
    "Normal",
    "Height",
    "Ambient",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureType(TextureType e) {
  if (e < TextureType_Diffuse || e > TextureType_Ambient) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesTextureType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct TextureT : public flatbuffers::NativeTable {
  typedef Texture TableType;
  TextureType type;
  std::string path;
  TextureT()
      : type(TextureType_Diffuse) {
  }
};

struct Texture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PATH = 6
  };
  TextureType type() const {
    return static_cast<TextureType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
  TextureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Texture> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(TextureType type) {
    fbb_.AddElement<int8_t>(Texture::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Texture::VT_PATH, path);
  }
  explicit TextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureBuilder &operator=(const TextureBuilder &);
  flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Texture> CreateTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    TextureType type = TextureType_Diffuse,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Texture> CreateTextureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    TextureType type = TextureType_Diffuse,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return ModelData::CreateTexture(
      _fbb,
      type,
      path__);
}

flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder &_fbb, const TextureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshT : public flatbuffers::NativeTable {
  typedef Mesh TableType;
  std::vector<Vec3> positions;
  std::vector<Vec3> normals;
  std::vector<Vec2> texCoords;
  std::vector<Vec3> tangents;
  std::vector<Vec3> bitangents;
  std::vector<uint16_t> indices;
  std::vector<std::unique_ptr<TextureT>> textures;
  MeshT() {
  }
};

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONS = 4,
    VT_NORMALS = 6,
    VT_TEXCOORDS = 8,
    VT_TANGENTS = 10,
    VT_BITANGENTS = 12,
    VT_INDICES = 14,
    VT_TEXTURES = 16
  };
  const flatbuffers::Vector<const Vec3 *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_POSITIONS);
  }
  const flatbuffers::Vector<const Vec3 *> *normals() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_NORMALS);
  }
  const flatbuffers::Vector<const Vec2 *> *texCoords() const {
    return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_TEXCOORDS);
  }
  const flatbuffers::Vector<const Vec3 *> *tangents() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_TANGENTS);
  }
  const flatbuffers::Vector<const Vec3 *> *bitangents() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_BITANGENTS);
  }
  const flatbuffers::Vector<uint16_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_INDICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyVector(normals()) &&
           VerifyOffset(verifier, VT_TEXCOORDS) &&
           verifier.VerifyVector(texCoords()) &&
           VerifyOffset(verifier, VT_TANGENTS) &&
           verifier.VerifyVector(tangents()) &&
           VerifyOffset(verifier, VT_BITANGENTS) &&
           verifier.VerifyVector(bitangents()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfTables(textures()) &&
           verifier.EndTable();
  }
  MeshT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mesh> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> positions) {
    fbb_.AddOffset(Mesh::VT_POSITIONS, positions);
  }
  void add_normals(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> normals) {
    fbb_.AddOffset(Mesh::VT_NORMALS, normals);
  }
  void add_texCoords(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> texCoords) {
    fbb_.AddOffset(Mesh::VT_TEXCOORDS, texCoords);
  }
  void add_tangents(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> tangents) {
    fbb_.AddOffset(Mesh::VT_TANGENTS, tangents);
  }
  void add_bitangents(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> bitangents) {
    fbb_.AddOffset(Mesh::VT_BITANGENTS, bitangents);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> indices) {
    fbb_.AddOffset(Mesh::VT_INDICES, indices);
  }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textures) {
    fbb_.AddOffset(Mesh::VT_TEXTURES, textures);
  }
  explicit MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> normals = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> texCoords = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> tangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> bitangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textures = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_textures(textures);
  builder_.add_indices(indices);
  builder_.add_bitangents(bitangents);
  builder_.add_tangents(tangents);
  builder_.add_texCoords(texCoords);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mesh> CreateMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Vec3> *positions = nullptr,
    const std::vector<Vec3> *normals = nullptr,
    const std::vector<Vec2> *texCoords = nullptr,
    const std::vector<Vec3> *tangents = nullptr,
    const std::vector<Vec3> *bitangents = nullptr,
    const std::vector<uint16_t> *indices = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textures = nullptr) {
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<Vec3>(*positions) : 0;
  auto normals__ = normals ? _fbb.CreateVectorOfStructs<Vec3>(*normals) : 0;
  auto texCoords__ = texCoords ? _fbb.CreateVectorOfStructs<Vec2>(*texCoords) : 0;
  auto tangents__ = tangents ? _fbb.CreateVectorOfStructs<Vec3>(*tangents) : 0;
  auto bitangents__ = bitangents ? _fbb.CreateVectorOfStructs<Vec3>(*bitangents) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint16_t>(*indices) : 0;
  auto textures__ = textures ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textures) : 0;
  return ModelData::CreateMesh(
      _fbb,
      positions__,
      normals__,
      texCoords__,
      tangents__,
      bitangents__,
      indices__,
      textures__);
}

flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb, const MeshT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
  typedef Model TableType;
  std::vector<std::unique_ptr<MeshT>> meshes;
  ModelT() {
  }
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *>(VT_MESHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes) {
    fbb_.AddOffset(Model::VT_MESHES, meshes);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Mesh>> *meshes = nullptr) {
  auto meshes__ = meshes ? _fbb.CreateVector<flatbuffers::Offset<Mesh>>(*meshes) : 0;
  return ModelData::CreateModel(
      _fbb,
      meshes__);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TextureT *Texture::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TextureT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Texture::UnPackTo(TextureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = path(); if (_e) _o->path = _e->str(); };
}

inline flatbuffers::Offset<Texture> Texture::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTexture(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder &_fbb, const TextureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _path = _o->path.empty() ? 0 : _fbb.CreateString(_o->path);
  return ModelData::CreateTexture(
      _fbb,
      _type,
      _path);
}

inline MeshT *Mesh::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MeshT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Mesh::UnPackTo(MeshT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = positions(); if (_e) { _o->positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->positions[_i] = *_e->Get(_i); } } };
  { auto _e = normals(); if (_e) { _o->normals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normals[_i] = *_e->Get(_i); } } };
  { auto _e = texCoords(); if (_e) { _o->texCoords.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->texCoords[_i] = *_e->Get(_i); } } };
  { auto _e = tangents(); if (_e) { _o->tangents.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tangents[_i] = *_e->Get(_i); } } };
  { auto _e = bitangents(); if (_e) { _o->bitangents.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bitangents[_i] = *_e->Get(_i); } } };
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indices[_i] = _e->Get(_i); } } };
  { auto _e = textures(); if (_e) { _o->textures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textures[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Mesh> Mesh::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMesh(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb, const MeshT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _positions = _o->positions.size() ? _fbb.CreateVectorOfStructs(_o->positions) : 0;
  auto _normals = _o->normals.size() ? _fbb.CreateVectorOfStructs(_o->normals) : 0;
  auto _texCoords = _o->texCoords.size() ? _fbb.CreateVectorOfStructs(_o->texCoords) : 0;
  auto _tangents = _o->tangents.size() ? _fbb.CreateVectorOfStructs(_o->tangents) : 0;
  auto _bitangents = _o->bitangents.size() ? _fbb.CreateVectorOfStructs(_o->bitangents) : 0;
  auto _indices = _o->indices.size() ? _fbb.CreateVector(_o->indices) : 0;
  auto _textures = _o->textures.size() ? _fbb.CreateVector<flatbuffers::Offset<Texture>> (_o->textures.size(), [](size_t i, _VectorArgs *__va) { return CreateTexture(*__va->__fbb, __va->__o->textures[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ModelData::CreateMesh(
      _fbb,
      _positions,
      _normals,
      _texCoords,
      _tangents,
      _bitangents,
      _indices,
      _textures);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ModelT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = meshes(); if (_e) { _o->meshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshes[_i] = std::unique_ptr<MeshT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _meshes = _o->meshes.size() ? _fbb.CreateVector<flatbuffers::Offset<Mesh>> (_o->meshes.size(), [](size_t i, _VectorArgs *__va) { return CreateMesh(*__va->__fbb, __va->__o->meshes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ModelData::CreateModel(
      _fbb,
      _meshes);
}

inline const ModelData::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<ModelData::Model>(buf);
}

inline const ModelData::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ModelData::Model>(buf);
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ModelData::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ModelData::Model>(nullptr);
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ModelData::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ModelData::Model> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ModelT> UnPackModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ModelT>(GetModel(buf)->UnPack(res));
}

}  // namespace ModelData

#endif  // FLATBUFFERS_GENERATED_MODEL_MODELDATA_H_
